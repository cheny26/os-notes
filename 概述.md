# 操作系统基本概念

## 定义

操作系统是指**控制和管理整个计算机系统的硬件和软件资源**，并合理的组织和调度计算机的工作和资源的分配，以**提供给用户和其他软件方便的接口和环境**，是计算机系统中最基本的**系统软件**。





## 功能和目标

- **资源管理**

  > 操作系统负责对计算机的各种资源（如处理器、内存、磁盘、输入输出设备等）进行有效的分配、调度和使用，以提高计算机的性能和效率。

- **向上层提供服务**

  >  操作系统为用户和应用程序提供各种服务，如文件管理、进程管理、网络通信、安全保护等，以方便用户的操作和开发。
  >
  >  + 给普通用户用的：GUI图形界面，命令接口（联机命令接口，脱机命令接口）
  >    + 联机命令接口又称**交互式命令接口**：用户输入一条指令，操作系统就执行一条
  >    + 脱机命令接口又称**批处理接口**：用户输入一堆指令，操作系统运行一堆指令
  >  + 给软件/程序员用的：程序接口

- **扩展硬件机器**

  > 操作系统通过软件的方式，对硬件的功能进行扩展和改进，使得用户可以使用更高级、更友好、更智能的虚拟机器，而不是直接面对复杂的裸机。





## 特征

+ **并发**

  > 1. 操作系统能够同时运行着多个程序，宏观上是同时运行，但是微观上是交替运行的
  > 2. 操作系统伴随着多道技术而出现，所以**操作系统和程序并发是一起诞生的**

+ **共享**

  > 1. 共享即资源共享，是指系统中的资源可**供多个并发执行的程序**共同使用
  > 2. 共享可分为互斥共享和同时共享：
  >    + 互斥共享：**一个时间段内只允许一个进程访问该资源**，如用QQ和微信视频，同一时间段内只允许一个进程使用摄像头
  >    + 同时共享：**一个时间段内运行多个进程“同时”访问该资源**（宏观上同时，微观上交替进行），如QQ和微信可以同时发送文件

**并发性和共享性互为存在条件**

- 如果没有并发性，系统中只有一个程序在运行，那么共享性就没有意义，因为不需要对资源进行分配和管理。
- 如果没有共享性，系统中的资源不能被多个程序共同使用，那么并发性就无法实现，因为多个程序无法同时或交替地访问资源。



+ 虚拟

  > 1. 虚拟是指把一个**物理上的实体变为若干个逻辑上的对应物。**物理实体（前者）是实际存在的，而逻辑上
  >    对应物（后者）是用户感受到的。
  > 2. 虚拟技术分为**时分复用技术**和**空分复用技术**。

+ 异步

  > 1. 异步是指多道程序环境允许**多个程序并发执行**，但由于资源有限，如cpu只有一个，**进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进**。







# 操作系统的发展与分类

![image-20231213001620003](https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312130016291.png)





# 操作系统运行环境

## 运行机制

![image-20231212221531767](https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122215277.png)

内核态-->用户态：执行一条修改PSW的特权指令（CPU中有一个程序状态寄存器PSW，1表示内核态，0表示用户态）

用户态-->内核态：由中断引起，硬件自动完成





## 中断和异常

![image-20231212224827281](https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122248012.png)



## 系统调用

+ **什么是系统调用**

  > 系统调用是**操作系统提供给应用程序使用的接口**，可以理解为一种可供应用程序调用的特殊函数
  >
  > **应用程序可以通过系统调用来请求获得操作系统内核的服务**

+ **系统调用与库函数的区别**

  <img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122315907.png" alt="image-20231212231554089" style="zoom:67%;" />

+ **什么功能用到系统调用**

  > 凡是与**共享资源有关的操作**（如存储分配、/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
  >
  > + 设备管理：完成设备的请求/释放/启动等功能
  > + 文件管理：完成文件的读/写/伧创建/删除等功能
  > + 进程控制：完成进程的创建/撤销/阻塞/唤醒等功能
  > + 进程通信：完成进程之间的消息传递/信号传递等功能
  > + 内存管理：完成内存的分配/回收等功能

  

+ **系统调用的过程**

  ![image-20231212232102046](https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122321568.png)

  1. 传递系统调用参数

  2. 执行陷入指令（用户态）

     > **用户态执行陷入指令，指令执行之后引发内中断，进入核心态**
     >
     > **陷入指令时唯一一个只能在用户态执行，而不能在核心态执行的指令**

  3. 执行系统调用相应服务程序（核心态·）

  4. 返回用户程序





# 操作系统体系结构

**内核介绍**

+ 内核是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序
+ 操作系统内核运行在内核态，非内核功能运行在用户态

<img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122112465.png" alt="image-20231212211237883" style="zoom:67%;" />

**大内核**

+ 将操作系统的主要模块都作为系统内核
+ 优点：高性能
+ 缺点：内核代码庞大，结构混乱，难以维护

**微内核**

+ 只有与硬件处理紧密相关的部分和一些较基本的功能
+ 优点：内核功能少，结构清晰，方便维护
+ 缺点：客户和服务器、服务器和服务器之间的通信都需经过微内核，上下文切换频繁



**大内核与微内核的对比**

<img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122113104.png" alt="image-20231212211349929" style="zoom:67%;" />

<img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122114558.png" alt="image-20231212211445357" style="zoom:67%;" />



# 操作系统引导

![image-20231212203411233](https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312122034955.png)

1. 上电自检（Power-On Self-Test，POST）：

   > 当计算机上电时，计算机**硬件执行**自检过程。这个过程确保计算机硬件的基本功能正常，包括内存、CPU、硬盘、显卡等。

2. BIOS/UEFI初始化：

   > + 计算机上电后，会首先**执行基本输入输出系统（Basic Input/Output System，BIOS）**或统一可扩展固件接口（Unified Extensible Firmware Interface，UEFI）的初始化过程。
   >
   > + BIOS/UEFI负责识别和初始化连接到计算机的硬件设备，如硬盘、键盘、显示器等。

3. 引导设备的选择：

   > + BIOS/UEFI在初始化后，会**寻找引导设备**，通常是硬盘、固态硬盘或其他可引导的媒体。
   >
   > + 引导设备通常包含引导记录（Boot Record），这是一个特殊的区域，其中包含有关如何引导操作系统的信息。

4. 主引导记录（Master Boot Record，MBR）或EFI系统分区（ESP）：

   > + 如果使用传统BIOS引导，计算机会**查找硬盘上的主引导记录（MBR）。MBR包含引导加载程序和分区表。**
   >
   > + 如果使用UEFI引导，计算机会查找EFI系统分区（ESP），其中包含了用于引导操作系统的文件。

5. 引导加载程序的执行：

   > + 引导记录包含引导加载程序（Boot Loader），这是一个小型程序，负责**加载操作系统内核到内存中**。
   >
   > + 引导加载程序可能会提供一个菜单，允许用户选择要引导的操作系统，或者直接加载默认的操作系统。

6. 操作系统内核的加载：

   > + 一旦引导加载程序确定要加载哪个操作系统，它会将操作系统内核加载到计算机的内存中。
   >
   > + 操作系统内核通常是一个压缩的文件，加载后会在内存中解压缩并开始执行。

7. 操作系统初始化：

   > + 一旦操作系统内核加载到内存中，操作系统开始**初始化系统的各个部分**，包括设备驱动程序、文件系统等。
   >
   > + 最终，操作系统准备好接受用户的命令或执行预定义的任务





# 虚拟机

> 虚拟机：使用虚拟化技术，将一台**物理机器虚拟化为多台虚拟机器**(Virtual Machine,VM),每个虚拟机器都可以独立运行一个操作系统



+ 第一类虚拟机：直接运行在硬件上

  <img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312121906632.png" alt="image-20231212190537391" style="zoom: 67%;" />

+ 第二类虚拟机：运行在宿主操作系统上

  <img src="https://chen-y-1311235303.cos.ap-guangzhou.myqcloud.com/MyDraw/202312121907073.png" alt="image-20231212190721268" style="zoom:67%;" />



**第一类虚拟机与第二类虚拟机的对比：**

| 知识点             | 第一类VMM                                                    | 第二类VMM                                                    |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 对物理资源的控制权 | 直接**运行在硬件**之上，能直接控制和分配物理资源             | **运行在 Host OS** 之上，依赖于 Host OS 为其分配物理资源     |
| 资源分配方式       | 在安装 Guest OS 时，VMM 要在原本的硬盘上自行分配存储空问，类似于外核的分配方式，**分配未经抽象的物理硬件** | Guest OS 拥有自己的**虚拟磁盘**，该盘实际上是 Host OS 文件系统中的一个大文件。Guest OS 分配到的内存是**虚拟内存** |
| 性能               | **性能更好**                                                 | **性能更差**，需要 Host OS 作为中介                          |
| 可支持的虚拟机数量 | **更多，**不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机 | **更少**，Host OS 本身需要使用物理资源，Host OS 上运行的其他进程也需要物理资源 |
| 虚拟机的可迁移性   | 更差                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛 |
| 运行模式           | **运行在最高特权级**(Ring 0)，可以执行最高特权的指令         | 部分运行在用户态、部分运行在内核态。Guest OS 发出的系统调用会被 VMM 截获，并转化为 **VMM 对 Host OS 的系统调用** |
